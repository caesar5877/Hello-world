缓存 (Cache) 是一种**旨在提高查询效率的存储**。它与数据库的不同之处在于，**缓存是易失的**，这意味着当缓存服务器宕机时，数据会丢失。

### 缓存的目的 (Purpose of Cache)

引入缓存的主要原因是为了解决系统中的性能瓶颈，主要体现在以下几个方面：
*   **提高延迟 (Improve Latency)**：从内存读取 1 MB 数据比从磁盘读取快约 100 倍。缓存可以将数据物理上更接近用户，例如通过内容分发网络 (CDN)。然而，引入缓存会增加复杂性，因此需要根据非功能性需求来判断延迟的改进是否能为最终用户带来价值。
*   **提高吞吐量 (Improve Throughput)**：如果内存比磁盘快 100 倍，理论上在相同时间内可以处理 100 倍的工作量。当单个数据库无法处理高每秒查询次数 (QPS) 时，缓存可以作为一个解决方案。
*   **改善带宽 (Improve Bandwidth)**：与数据复制类似，通过将数据源物理上移近用户，可以减少数据在互联网上传输的字节量，从而改善整体带宽容量。CDN 就是这种方法的典型例子。

### 缓存考量因素 (Cache Considerations)

在使用缓存时，需要考虑一些关键因素：
*   **缓存命中率 (Cache Hit Rate)**：缓存命中率是指请求的数据在缓存中找到的比例。如果缓存命中率很低，可能意味着缓存没有充分利用，并且由于维护缓存的成本，可能不值得使用。需要根据用户的查询模式来做假设，例如，如果用户只读取一次数据，那么缓存就没有意义。
*   **缓存内容 (What Are You Caching?)**：仅仅说使用缓存不足够，必须明确地说明要缓存什么。例如，键是什么，值是什么，以及相关的失效策略。对缓存细节的讨论非常重要，比如是缓存整个搜索查询结果，还是缓存文本令牌。

### 写入缓存策略 (Write to Cache Strategies)

数据写入缓存和底层数据存储的方式有几种策略：
*   **写穿透 (Write-Through)**：数据**同步地写入缓存和底层数据存储**。
    *   **优点**：数据在缓存和数据存储中都存在。
    *   **缺点**：写入延迟较高，可用性较低，因为需要同步写入两个源，原子性也无法保证。
*   **写回 (Write-Back)**：数据**首先写入缓存，然后异步地更新到数据库**。
    *   **优点**：写入延迟较低，数据可以立即被读取服务。
    *   **缺点**：如果缓存在数据持久化到数据库之前宕机，数据可能会丢失。在面试中，如果写入延迟要求高且可以接受偶尔的数据丢失，这是一个可行的选项。
*   **写环绕 (Write-Around)**：系统**只写入数据库，不写入缓存**。
    *   **优点**：数据首先持久化到磁盘，具有更好的持久性。
    *   **缺点**：缓存不会被预填充，首次访问时延迟会较高。更新和预热缓存会增加额外的复杂性。通常可以结合“读穿透” (Read-Through) 策略，即当缓存未命中时，从数据库中获取数据并填充缓存。

### 缓存失效策略 (Cache Invalidation Strategies)

缓存失效是计算机科学中最困难的问题之一。当底层数据源发生变化时，需要确保缓存数据及时更新。
*   **监听值变化 (Have a Listener on the Values)**：当任何依赖的值发生变化时，立即删除缓存值。
    *   **优点**：缓存立即更新，数据新鲜。
    *   **缺点**：依赖于数据流，如果依赖项很多，可能导致大量不必要的失效。构建监听管道可能成本高昂。
*   **定期任务 (Have a Periodic Job to Calculate the Cache Value)**：通过定期任务计算并更新缓存值。
    *   **优点**：实现简单，无需监听依赖项，用户查询时数据已预填充。
    *   **缺点**：数据新鲜度取决于运行频率，可能导致数据陈旧。如果依赖值不常查询，可能浪费资源。
*   **缓存底层并扇入读取 (Cache a Lower Layer and Fan-In Read)**：不是为单个值进行超快速读取优化，而是通过读取多个缓存层的值并即时计算，牺牲一些速度以满足非功能性需求。
*   **通过 TTL 过期 (Expiration Through TTL)**：为缓存条目设置一个生存时间 (Time-To-Live, TTL)，过期后自动失效。
    *   **优点**：简单有效。
    *   **缺点**：TTL 越短，缓存未命中越多；TTL 越长，数据越可能陈旧，并可能浪费缓存内存。例如，浏览器通过 TTL 失效 DNS 地址。

### 缓存淘汰策略 (Cache Eviction Strategies)

由于缓存空间有限且昂贵，需要淘汰不常用的数据。目标是在限制内存使用的同时，保持合理的缓存命中率。
*   **最近最少使用 (Least Recently Used, LRU)**：淘汰最近最少被使用的数据。基于的直觉是最近未访问的数据将来也不太可能被访问。
*   **最不经常使用 (Least Frequently Used, LFU)**：淘汰访问频率最低的数据。基于的直觉是经常访问的数据应该继续被访问。
*   **自定义淘汰 (Custom Eviction)**：根据特定的查询模式和预算，使用启发式方法来预测缓存命中率。

### 缓存故障场景与冗余 (Cache Failure Scenario and Redundancy)

缓存也可能崩溃，导致数据丢失，从而可能对底层数据库造成“惊群效应” (thundering-herd)。
*   **周期性快照 (Periodic Snapshot)**：缓存定期创建数据备份文件。当缓存宕机时，可以使用备份文件重新创建缓存。
    *   **优点**：写入速度快，宕机时有时间点快照恢复。
    *   **缺点**：数据可能过时，重建快照需要时间。
*   **预写日志 (Write-Ahead Log, WAL)**：在写入缓存之前，先将操作写入磁盘上的 WAL。如果缓存失效，可以从 WAL 重放操作来恢复。
    *   **优点**：缓存拥有最新记录，宕机时可以从上次检查点重放恢复。
    *   **缺点**：写入速度会变慢，重放日志重建缓存可能需要时间。
*   **无备份 (No Backup)**：某些系统的缓存数据具有高度瞬时性，即使有备份，数据也可能过时。例如，网约车服务的司机位置更新，每次更新都会覆盖旧数据，因此可能不需要备份。
*   **复制 (Replication)**：像数据库一样，缓存也可以进行复制。当缓存服务器宕机时，可以从其他副本读取请求。

### 数据结构 (Data Structure)

缓存不一定只是键值存储，也可以是服务器上托管的内存数据结构，例如用于类型提示 (type-ahead) 的 Trie 或用于基于位置的查询的四叉树 (Quadtree)。

### 注意事项 (Warning)

**常见的误解是认为缓存直接改善带宽。** 然而，如果瓶颈是网络本身，位于同一数据中心的缓存服务器并不能显著改善用户体验。将数据源移近用户，例如通过 CDN，才能真正改善带宽。

### 惊群效应 (Thundering Herd)

当缓存数据冷（即缓存中没有数据）时，大量请求同时访问底层数据源，可能导致“惊群效应”，使系统崩溃。
*   **缓存阻塞 (Cache Blocking)**：一种解决方案是**缓存阻塞**，即只有一个请求负责从主数据源获取数据，其他请求则等待。
    *   **优点**：防止对底层系统的过载。
    *   **缺点**：如果负责的请求失败，其他请求可能会长时间等待。可以通过设置超时机制来缓解。
